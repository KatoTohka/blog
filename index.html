<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  
  <meta name="author" content="John Doe">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Hexo"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Hexo</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2023/02/21/6.824/lab2总结/"><span>lab2总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/02/21/6.824/lab2总结/" rel="bookmark">
        <time class="entry-date published" datetime="2023-02-21T11:34:57.000Z">
          2023-02-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="简单的-Raft-流程："><a href="#简单的-Raft-流程：" class="headerlink" title="简单的 Raft 流程："></a>简单的 Raft 流程：</h2><ol>
<li><p>Leader 收到 client 发送的 request。</p>
</li>
<li><p>Leader 将 request append 到自己的 log。</p>
</li>
<li><p>Leader 将对应的 log entry 发送给其他的 follower。</p>
</li>
<li><p>Leader 等待 follower 的结果，如果大多数节点提交了这个 log，则 apply。</p>
</li>
<li><p>Leader 将结果返回给 client。</p>
</li>
<li><p>Leader 继续处理下一次 request。</p>
</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/KatoTohka/pic1@main/202302211945520.png" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/KatoTohka/pic1@main/202302211946306.png" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/KatoTohka/pic1@main/202302211946875.png" alt="image"></p>
<p>从分层的角度看，整个系统包括：client 层，service 状态机层， raft 层，persister 持久化层</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原有，返回是否是leader和其任期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有，持久化状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> encodeState() []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有,回复先前的持久化状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有，服务端希望切换到快照</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有，服务端触发的日志压缩，删除掉已经被压缩的log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// leader发送的，如果无误则 follower 只能无条件接受。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> genInstallSnapshotArgs() *InstallSnapshotArgs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleInstallSnapshotReply(peer <span class="type">int</span>, args *InstallSnapshotArgs, reply *InstallSnapshotReply) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendInstallSnapshot(server <span class="type">int</span>, args *InstallSnapshotArgs, reply *InstallSnapshotReply) <span class="type">bool</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> genRequestVoteArgs() *RequestVoteArgs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求投票服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleRequestVoteReply(peer <span class="type">int</span>, args *RequestVoteArgs, reply *RequestVoteReply)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用RequestVote服务，RPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendRequestVote(server <span class="type">int</span>, args *RequestVoteArgs, reply *RequestVoteReply) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> broadcastHeartbeat(isHeartbeat <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> doReplicate(peer <span class="type">int</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> genAppendEntriesArgs(prevLogIndex <span class="type">int</span>) *AppendEntriesArgs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntriesReply(peer <span class="type">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendAppendEntries(server <span class="type">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> followerCommit(leaderCommit <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> leaderCommit() </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getFirstLog() Entry</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getLastLog() Entry</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> changeState(state State)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> reInitFollowTimer()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> reInitLeaderState()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有，应用层接口，获取command，返回index，term和成功与否</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Kill()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> killed() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applier()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有，定时器两个chan，等待heartbeatTimer和electionTimer过期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ticker()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicator(peer <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> needReplicating(peer <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原有，用来启动raft服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft</span><br></pre></td></tr></table></figure>

<h2 id="Raft结构体"><a href="#Raft结构体" class="headerlink" title="Raft结构体"></a>Raft结构体</h2><p>给出raft结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        sync.RWMutex        <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">	peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line">	<span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line">	<span class="comment">// state a Raft server must maintain.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有服务器上的持久性状态 (在响应 RPC 请求之前，已经更新到了稳定的存储设备)</span></span><br><span class="line">	<span class="comment">// 服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）</span></span><br><span class="line">	currentTerm <span class="type">int</span></span><br><span class="line">	<span class="comment">// 当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空</span></span><br><span class="line">	<span class="comment">// 即使节点重启，Raft 算法也能保证每个任期最多只有一个 leader。</span></span><br><span class="line">	votedFor <span class="type">int</span></span><br><span class="line">	voteCnt  <span class="type">int</span></span><br><span class="line">	<span class="comment">// 已经 committed 的日志，保证状态机可恢复。</span></span><br><span class="line">	logs []Entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有服务器上的易失性状态</span></span><br><span class="line">	<span class="comment">// 已知已提交的最高的日志条目的索引（初始值为0，单调递增）</span></span><br><span class="line">	<span class="comment">//leader 节点重启后可以通过 appendEntries rpc 逐渐得到不同节点的 matchIndex，从而确认 commitIndex</span></span><br><span class="line">	<span class="comment">//follower 只需等待 leader 传递过来的 commitIndex 即可</span></span><br><span class="line">	commitIndex <span class="type">int</span></span><br><span class="line">	<span class="comment">// 已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增）</span></span><br><span class="line">	lastApplied <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 领导人（服务器）上的易失性状态 每次选举后，leader 的此两个数组都应该立刻重新初始化并开始探测</span></span><br><span class="line">	<span class="comment">// 为每一个 follower 保存的，应该发送的下一份 entry index（初始值为领导人最后的日志条目的索引 +1  , last index + 1。）</span></span><br><span class="line">	nextIndex []<span class="type">int</span></span><br><span class="line">	<span class="comment">// 已确认的，已经同步到每一个 follower 的 entry index（初始值为0，根据复制状态不断递增，）</span></span><br><span class="line">	matchIndex []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	state   State</span><br><span class="line">	applyCh <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">	<span class="comment">// 用于在提交新条目后唤醒 applier goroutine</span></span><br><span class="line">	applyCond *sync.Cond</span><br><span class="line">	<span class="comment">// 用于通知复制器 goroutine 批量复制条目</span></span><br><span class="line">	replicatorCond []*sync.Cond</span><br><span class="line">	electionTimer  *time.Timer</span><br><span class="line">	heartbeatTimer *time.Timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>currentTerm,voteFor,log 需要持久化</p>
<p>commitidx ：leader通过matchIndex算出来，follower通过leader给，所以都不需要存,</p>
<p>对于leader而言，在对每个follower进行doreplicate操作时如果follower的prevLogIndex&gt;&#x3D;leader的第一条log的index话，就会进行appendentry的rpc请求，leader在收到rpc<strong>成功</strong>请求之后会进行进行一次leader的commit，这时就会根据已经匹配的matchIndex数量找到新的commitIndex进行commit</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> leaderCommit() &#123;</span><br><span class="line">	<span class="comment">//注意：是根据matchIndex，判断出那些log已经被大多数peer记录了</span></span><br><span class="line">	n := <span class="built_in">len</span>(rf.matchIndex)</span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="built_in">copy</span>(tmp, rf.matchIndex)</span><br><span class="line">	<span class="comment">//降序排序</span></span><br><span class="line">	sort.Sort(sort.Reverse(sort.IntSlice(tmp)))</span><br><span class="line">	<span class="comment">//找到新的commitIndex</span></span><br><span class="line">	newCommitIndex := tmp[n/<span class="number">2</span>]</span><br><span class="line">	<span class="keyword">if</span> newCommitIndex &gt; rf.commitIndex &#123;</span><br><span class="line">		<span class="comment">// leader只能提交当前任期下的日志</span></span><br><span class="line">		<span class="keyword">if</span> newCommitIndex &lt;= rf.getLastLog().Index &amp;&amp; rf.currentTerm == rf.logs[newCommitIndex-rf.getFirstLog().Index].Term &#123;</span><br><span class="line">			DPrintf(<span class="string">&quot;[Node %d] advance commitIndex from %d to %d with matchIndex %v in term %d&quot;</span>,</span><br><span class="line">				rf.me, rf.commitIndex, newCommitIndex, rf.matchIndex, rf.currentTerm)</span><br><span class="line">			rf.commitIndex = newCommitIndex</span><br><span class="line">			rf.applyCond.Signal()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			DPrintf(<span class="string">&quot;[Node %d] can not advance commitIndex from %d because the term of newCommitIndex %d is not equal to currentTerm %d&quot;</span>,</span><br><span class="line">				rf.me, rf.commitIndex, newCommitIndex, rf.currentTerm)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于follower而言。在进行appendentries这个rpc调用时就会进行commit操作，这时会更新自己的commitindex</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> followerCommit(leaderCommit <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> leaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">      rf.commitIndex = Min(leaderCommit, rf.getLastLog().Index)</span><br><span class="line">      rf.applyCond.Signal()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lastappied 是被最后被apply的值，只有在宕机重启后读取持久数据时重置为第一个log的index，收到条件condinstallsnapshot时置为快照的最后一个index(ps.lastappied和commitindex这两个在这里一样)，还有在applier协程中commit过后我们需要apply这个entry时修改这个lastappied，这里其实commitindex也用到了，要保证我们apply的entry必须commit过</p>
<p>lastapplied和commitIndex其实也是一组，主要看下面代码的第一个for循环，我们可以看到我们的commit相当于就是apply，只是我们区分了步骤，在apply前的我们叫commit，我们在程序中修改的是commit的值，在applier中只有出现了新的commit我们就进行apply，所以commit在我们这相当于是apply的前置准备。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rf.lastApplied &gt;= rf.commitIndex &#123;</span><br><span class="line">   rf.applyCond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">lastApplied := rf.lastApplied</span><br><span class="line">firstLogIndex := rf.getFirstLog().Index</span><br><span class="line">commitIndex := rf.commitIndex</span><br><span class="line">applyEntries := <span class="built_in">make</span>([]Entry, commitIndex-lastApplied)</span><br><span class="line"><span class="built_in">copy</span>(applyEntries, rf.logs[lastApplied-firstLogIndex+<span class="number">1</span>:commitIndex-firstLogIndex+<span class="number">1</span>])</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">for</span> _, entry := <span class="keyword">range</span> applyEntries &#123;</span><br><span class="line">   applyMsg := ApplyMsg&#123;</span><br><span class="line">      CommandValid: <span class="literal">true</span>,</span><br><span class="line">      Command:      entry.Command,</span><br><span class="line">      CommandIndex: entry.Index,</span><br><span class="line">   &#125;</span><br><span class="line">   rf.applyCh &lt;- applyMsg</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">rf.lastApplied = Max(rf.lastApplied, commitIndex)</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure>

<p>nextIndex和matchIndex俩个数组是leader节点中统计follower的log的状态数组。这两个数组是成对出现的，在处理installsnapshot和appendentry时修改各自peer的状态。其中matchIndex在重置为leader时会将所有的peer(包括自己)设置为0，而nextIndex则会期望最优，取成lastlog.Index +1，但是不要怕，在service层start之后，leader的matchIndex自己会变成正确lastlog.Index + 1。</p>
<p>state是leader，follower，candidate等状态</p>
<p>applych是一个channel，用来存快照应用信息和log的应用的信息</p>
<p>applyCond *sync.Cond 用来控制是否唤醒appiler进程来写apply，只有log在commit之后才能apply</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在applier中，等待新的commit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applier() &#123;</span><br><span class="line">	<span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		<span class="keyword">for</span> rf.lastApplied &gt;= rf.commitIndex &#123;</span><br><span class="line">			rf.applyCond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> followerCommit(leaderCommit <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> leaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">		rf.commitIndex = Min(leaderCommit, rf.getLastLog().Index)</span><br><span class="line">		rf.applyCond.Signal()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> leaderCommit() &#123;</span><br><span class="line">	<span class="comment">//注意：是根据matchIndex，判断出那些log已经被大多数peer记录了</span></span><br><span class="line">	n := <span class="built_in">len</span>(rf.matchIndex)</span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="built_in">copy</span>(tmp, rf.matchIndex)</span><br><span class="line">	<span class="comment">//降序排序</span></span><br><span class="line">	sort.Sort(sort.Reverse(sort.IntSlice(tmp)))</span><br><span class="line">	<span class="comment">//找到新的commitIndex</span></span><br><span class="line">	newCommitIndex := tmp[n/<span class="number">2</span>]</span><br><span class="line">	<span class="keyword">if</span> newCommitIndex &gt; rf.commitIndex &#123;</span><br><span class="line">		<span class="comment">// leader只能提交当前任期下的日志</span></span><br><span class="line">		<span class="keyword">if</span> newCommitIndex &lt;= rf.getLastLog().Index &amp;&amp; rf.currentTerm == rf.logs[newCommitIndex-rf.getFirstLog().Index].Term &#123;</span><br><span class="line">			DPrintf(<span class="string">&quot;[Node %d] advance commitIndex from %d to %d with matchIndex %v in term %d&quot;</span>,</span><br><span class="line">				rf.me, rf.commitIndex, newCommitIndex, rf.matchIndex, rf.currentTerm)</span><br><span class="line">			rf.commitIndex = newCommitIndex</span><br><span class="line">			rf.applyCond.Signal()    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			DPrintf(<span class="string">&quot;[Node %d] can not advance commitIndex from %d because the term of newCommitIndex %d is not equal to currentTerm %d&quot;</span>,</span><br><span class="line">				rf.me, rf.commitIndex, newCommitIndex, rf.currentTerm)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>replicatorCond []*sync.Cond，我们为每个peer创建一个replicator，需要通过这个条件变量在有新的entry到来时唤醒协程进行复制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicator(peer <span class="type">int</span>) &#123;</span><br><span class="line">   rf.replicatorCond[peer].L.Lock()</span><br><span class="line">   <span class="keyword">defer</span> rf.replicatorCond[peer].L.Unlock()</span><br><span class="line">   <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">      <span class="keyword">for</span> !rf.needReplicating(peer) &#123;</span><br><span class="line">         rf.replicatorCond[peer].Wait()</span><br><span class="line">      &#125;</span><br><span class="line">      rf.doReplicate(peer)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> broadcastHeartbeat(isHeartbeat <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">		<span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> isHeartbeat &#123;</span><br><span class="line">			<span class="comment">//立刻发送保证leader地位</span></span><br><span class="line">			<span class="keyword">go</span> rf.doReplicate(peer)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//只需向replicatorCond goroutine 发出信号即可批量发送entry</span></span><br><span class="line">			rf.replicatorCond[peer].Signal()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// Your code here (2B).</span></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> rf.state == Leader &#123;</span><br><span class="line">		lastLog := rf.getLastLog()</span><br><span class="line">		newLog := Entry&#123;</span><br><span class="line">			<span class="comment">// 无语，漏了个+1，卡了半天</span></span><br><span class="line">			Index:   lastLog.Index + <span class="number">1</span>,</span><br><span class="line">			Term:    rf.currentTerm,</span><br><span class="line">			Command: command,</span><br><span class="line">		&#125;</span><br><span class="line">		rf.logs = <span class="built_in">append</span>(rf.logs, newLog)</span><br><span class="line">		<span class="comment">//先改自己的</span></span><br><span class="line">		rf.matchIndex[rf.me] = newLog.Index</span><br><span class="line">		rf.nextIndex[rf.me] = newLog.Index + <span class="number">1</span></span><br><span class="line">		rf.persist()</span><br><span class="line">		DPrintf(<span class="string">&quot;[Node %v] receives a new command[%v] to replicate in term %v&quot;</span>, rf.me, newLog, rf.currentTerm)</span><br><span class="line">		rf.broadcastHeartbeat(<span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span> newLog.Index, newLog.Term, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">electionTimer  *time.Timer</span><br><span class="line">heartbeatTimer *time.Timer</span><br></pre></td></tr></table></figure>

<p>这两个是一个定时器，我们只要监听channel，分别处理选取和心跳超时事件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ticker() &#123;</span><br><span class="line">   <span class="keyword">for</span> rf.killed() == <span class="literal">false</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Your code here to check if a leader election should</span></span><br><span class="line">      <span class="comment">// be started and to randomize sleeping time using</span></span><br><span class="line">      <span class="comment">// time.Sleep().</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-rf.heartbeatTimer.C:</span><br><span class="line">         rf.mu.Lock()</span><br><span class="line">         <span class="comment">// 只有leader才会心跳</span></span><br><span class="line">         <span class="keyword">if</span> rf.state == Leader &#123;</span><br><span class="line">            DPrintf(<span class="string">&quot;[Leader %d] Heartbeat elapsed, start new Heartbeat&quot;</span>, rf.me)</span><br><span class="line">            rf.broadcastHeartbeat(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 发送心跳后重置心跳计时器</span></span><br><span class="line">            rf.heartbeatTimer.Reset(FixedHeartBeatTimeout())</span><br><span class="line">         &#125;</span><br><span class="line">         rf.mu.Unlock()</span><br><span class="line">      <span class="keyword">case</span> &lt;-rf.electionTimer.C:</span><br><span class="line">         rf.mu.Lock()</span><br><span class="line">         DPrintf(<span class="string">&quot;[Node %d] election elapsed, start election&quot;</span>, rf.me)</span><br><span class="line">         rf.changeState(Candidate)</span><br><span class="line">         rf.currentTerm += <span class="number">1</span></span><br><span class="line">         rf.startElection()</span><br><span class="line">         <span class="comment">// startElection异步发起投票后返回，重置选举超时时间</span></span><br><span class="line">         rf.electionTimer.Reset(RandomElectionTimeOut())</span><br><span class="line">         rf.mu.Unlock()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC结构体"><a href="#RPC结构体" class="headerlink" title="RPC结构体"></a>RPC结构体</h2><p>vote请求不但要给出自己的Term和PeerId，还要给出自己的LastLogIndex和LastLogTerm来保证safty argument</p>
<p>返回vote请求给出自己的term以及是否给pass的granted，只有granted了之后才计入选票</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestVoteArgs 由候选人负责调用用来征集选票</span></span><br><span class="line"><span class="comment">// example RequestVote RPC arguments structure.</span></span><br><span class="line"><span class="comment">// field names must start with capital letters!</span></span><br><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">	<span class="comment">// 候选人的任期号</span></span><br><span class="line">	Term <span class="type">int</span></span><br><span class="line">	<span class="comment">// 请求选票的候选人的 ID</span></span><br><span class="line">	CandidateId <span class="type">int</span></span><br><span class="line">	<span class="comment">// 候选人的最后日志条目的索引值</span></span><br><span class="line">	LastLogIndex <span class="type">int</span></span><br><span class="line">	<span class="comment">// 候选人的最后日志条目的任期号</span></span><br><span class="line">	LastLogTerm <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestVoteReply</span></span><br><span class="line"><span class="comment">// example RequestVote RPC reply structure.</span></span><br><span class="line"><span class="comment">// field names must start with capital letters!</span></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// Your data here (2A).</span></span><br><span class="line">   <span class="comment">// 当前任期号，以便于候选人去更新自己的任期号</span></span><br><span class="line">   Term <span class="type">int</span></span><br><span class="line">   <span class="comment">// 候选人赢得了此张选票时为真</span></span><br><span class="line">   VoteGranted <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>appendentries的请求是leader发出的，给出自己的term和id，并且给出希望复制的log的index和term，自己的最高日志的leadercommit给follower用来进行commit的，只要我们leader的log的commit过，我们希望follower也进行相同的commit操作。</p>
<p>appendentries的返回响应主要是给出自己的Term以及返回是否成功，如果返回不成功的话我们就行了快速恢复的操作。给出XTerm，XIndex和XLen帮助leader给出正确的下一步log（可能迭代多次）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppendEntriesArgs 由leader调用，用于日志条目的复制，同时也被当做心跳使用</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 领导人的任期</span></span><br><span class="line">	Term <span class="type">int</span></span><br><span class="line">	<span class="comment">// 领导人 ID 因此跟随者可以对客户端进行重定向（跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人)</span></span><br><span class="line">	LeaderId <span class="type">int</span></span><br><span class="line">	<span class="comment">// 紧邻新日志条目之前的那个日志条目的索引</span></span><br><span class="line">	PrevLogIndex <span class="type">int</span></span><br><span class="line">	<span class="comment">// 紧邻新日志条目之前的那个日志条目的任期</span></span><br><span class="line">	PrevLogTerm <span class="type">int</span></span><br><span class="line">	<span class="comment">// 需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个）</span></span><br><span class="line">	Entries []Entry</span><br><span class="line">	<span class="comment">// 领导人的已知已提交的最高的日志条目的索引</span></span><br><span class="line">	LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 当前任期，对于领导人而言 它会更新自己的任期</span></span><br><span class="line">    Term <span class="type">int</span></span><br><span class="line">    <span class="comment">// 如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true</span></span><br><span class="line">    Success <span class="type">bool</span></span><br><span class="line">    <span class="comment">// 快速恢复</span></span><br><span class="line">    XTerm  <span class="type">int</span></span><br><span class="line">    XIndex <span class="type">int</span></span><br><span class="line">    XLen   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>installsnapshot中我们需要给出和appendentries相似的参数。Term，id，最后的index和Term，以及快照数据。这里没有要图中的offset和done属性</p>
<p>这个 rpc 请求的返回体参数只有 term 一个，并不考虑成功与否；并且 rpc handler 实现中也可以不用像 AppendEntries 那样判断日志是否冲突；leader的快照仅需要判断日志是否过时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstallSnapshotArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//领导人的任期号</span></span><br><span class="line">	Term <span class="type">int</span></span><br><span class="line">	<span class="comment">//领导人的 ID，以便于跟随者重定向请求</span></span><br><span class="line">	LeaderId <span class="type">int</span></span><br><span class="line">	<span class="comment">//快照中包含的最后日志条目的索引值</span></span><br><span class="line">	LastIncludedIndex <span class="type">int</span></span><br><span class="line">	<span class="comment">//快照中包含的最后日志条目的任期号</span></span><br><span class="line">	LastIncludedTerm <span class="type">int</span></span><br><span class="line">	<span class="comment">//从偏移量开始的快照分块的原始字节</span></span><br><span class="line">	Data []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InstallSnapshotReply <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//当前任期号（currentTerm），便于领导人更新自己</span></span><br><span class="line">   Term <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h2><p>raft主要可以分为四个模块</p>
<ul>
<li><p>选主</p>
</li>
<li><p>日志复制</p>
</li>
<li><p>日志压缩(其实可以算日志复制的一个子任务)</p>
</li>
<li><p>持久化</p>
</li>
</ul>
<p>每个节点可以分为两种形态，handler和sender，对应follower和leader</p>
<p>因此对于leade和follower都要处理的方法需要两种处理逻辑</p>
<h3 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h3><p>需要注意的有以下几点：</p>
<h4 id="candidate："><a href="#candidate：" class="headerlink" title="candidate："></a>candidate：</h4><p>并行异步投票：发起投票时要异步并行去发起投票，从而不阻塞 ticker 协程，这样 candidate 再次 election timeout 之后才能自增 term 继续发起新一轮选举。</p>
<p>自己给自己投一票，不用发rpc。</p>
<p>投票统计：可以在函数内定义一个变量并利用 go 的闭包来实现，也可以在结构体中维护一个 votes 变量来实现。为了 raft 结构体更干净，我选择了前者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 候选者希望发起election</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection() &#123;</span><br><span class="line">	args := rf.genRequestVoteArgs()</span><br><span class="line">	DPrintf(<span class="string">&quot;[Node %v] starts election with RequestVoteArgs: %v&quot;</span>, rf.me, args)</span><br><span class="line">	<span class="comment">//先给自己投一票</span></span><br><span class="line">	rf.votedFor = rf.me</span><br><span class="line">	rf.persist()</span><br><span class="line">	rf.voteCnt = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">		<span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//异步向每个peer发起投票</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			reply := <span class="built_in">new</span>(RequestVoteReply)</span><br><span class="line">			<span class="comment">//调用sendRequestVote RPC 给每个peer</span></span><br><span class="line">			<span class="keyword">if</span> rf.sendRequestVote(peer, args, reply) &#123;</span><br><span class="line">				rf.mu.Lock()</span><br><span class="line">				<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">				rf.handleRequestVoteReply(peer, args, reply)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(peer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛弃过期请求的回复：对于过期请求的回复，直接抛弃就行，不要做任何处理，这一点 guidance 里面也有介绍到。</p>
<p>当选后立刻发送replicate请求，不能等replicator协程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 候选者处理投票者的reply</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleRequestVoteReply(peer <span class="type">int</span>, args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">	DPrintf(<span class="string">&quot;[Node %v] receives RequestVoteReply %v from [Node %v] after sending RequestVoteArgs %v in term %v&quot;</span>, rf.me, args, peer, reply, rf.currentTerm)</span><br><span class="line">	<span class="comment">//	一旦这个节点不在是candidate或者term增加了，后续传过来的投票就过期，丢弃</span></span><br><span class="line">	<span class="comment">// rf我们无法控制，只能通过加锁的方式控制在当前函数运行时不变，但是在此之前可能已经发生了变化</span></span><br><span class="line">	<span class="comment">// args代表rf(先前)任期的情况，reply和args是相同的term</span></span><br><span class="line">	<span class="keyword">if</span> rf.state == Candidate &amp;&amp; rf.currentTerm == args.Term &#123;</span><br><span class="line">		<span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">			DPrintf(<span class="string">&quot;[Node %v] finds a new leader [Node %v] with term %v and steps down in term %v&quot;</span>, rf.me, peer, reply.Term, rf.currentTerm)</span><br><span class="line">			rf.changeState(Follower)</span><br><span class="line">			<span class="comment">// rf改变状态，开启下一轮</span></span><br><span class="line">			rf.currentTerm = reply.Term</span><br><span class="line">			rf.votedFor = <span class="number">-1</span></span><br><span class="line">			rf.voteCnt = <span class="number">0</span></span><br><span class="line">			rf.persist()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">			<span class="comment">// 注意这里是由于在外面是异步的，一旦超过半数就立即作为leader</span></span><br><span class="line">			rf.voteCnt += <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> rf.voteCnt &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">				DPrintf(<span class="string">&quot;[Node %v] receives majority votes in term %v&quot;</span>, rf.me, rf.currentTerm)</span><br><span class="line">				rf.changeState(Leader)</span><br><span class="line">				rf.reInitLeaderState()</span><br><span class="line">				rf.voteCnt = <span class="number">0</span></span><br><span class="line">				<span class="comment">// 当选leader后立即发送心跳信号</span></span><br><span class="line">				rf.broadcastHeartbeat(<span class="literal">true</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="follower："><a href="#follower：" class="headerlink" title="follower："></a>follower：</h4><p>term小于自己为过期投票</p>
<p>term和自己相同但投过了票了就不投了</p>
<p>term比自己大时置自己为follower。<strong>注意：非常严重的错误是在重置follower时，需要考虑peer本来就是follower我们不应该重置electiontimeout并且在进行replicator时即使state一致我们依然需要重置electiontimeout</strong></p>
<p>安全保证使得我们选出的leader一定包含整个集群全部的commited的日志，我们希望更大的term和更长的index</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestVote - sendRequestVote RPC实际对应的函数</span></span><br><span class="line"><span class="comment">// example RequestVote RPC handler.</span></span><br><span class="line"><span class="comment">// 注意： 只有在 grant 投票时才重置选举超时时间，这样有助于网络不稳定条件下选主的 liveness 问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">   <span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">   rf.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">   <span class="keyword">defer</span> rf.persist()</span><br><span class="line">   <span class="comment">// defer print，如果参数是值，如rf.state,调用这条语句那一刻就固定了，不会改变</span></span><br><span class="line">   <span class="comment">// 如果参数是指针，如reply, 值会变化</span></span><br><span class="line">   <span class="keyword">defer</span> DPrintf(<span class="string">&quot;[Node %v]&#x27;s state is &#123;state %v,term %v&#125; before processing requestVoteRequest %v and reply requestVoteResponse %v&quot;</span>,</span><br><span class="line">      rf.me, rf.state, rf.currentTerm, args, reply)</span><br><span class="line">   <span class="comment">// 过期请求</span></span><br><span class="line">   <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">      reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">      reply.Term = rf.currentTerm</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 一个Term只能给一个peer投票</span></span><br><span class="line">   <span class="comment">// 当前任期已经投过票，不能在投票了</span></span><br><span class="line">   <span class="comment">// 注意：这是args.Term == rf.currentTerm前提下</span></span><br><span class="line">   <span class="comment">// rf.votedFor == -1 表示拥有投票权力</span></span><br><span class="line">   <span class="comment">// rf.voteFor != args.CandidateID 表示给被别人投过票</span></span><br><span class="line">   <span class="comment">// 那么rf.voteFor 需不需要额外处理？？？</span></span><br><span class="line">   <span class="keyword">if</span> args.Term == rf.currentTerm &amp;&amp; rf.votedFor != <span class="number">-1</span> &amp;&amp; rf.votedFor != args.CandidateId &#123;</span><br><span class="line">      reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">      reply.Term = rf.currentTerm</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 收到一个更高任期的RequestVoteArgs RPC，变为Follower, 采用这个新任期，清空votedFor, 从而重新获得投票权</span></span><br><span class="line">   <span class="comment">// 注意: 如果你当前不是follower, 需要重置选举计时器; 如果是, 不要重置选举计时器!</span></span><br><span class="line">   <span class="comment">// 因为它可能被其他候选者无限打断, 候选者总是在任期上占优！ ？？？</span></span><br><span class="line">   state := rf.state</span><br><span class="line">   <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">      rf.changeState(Follower)</span><br><span class="line">      <span class="keyword">if</span> state != Follower &#123;</span><br><span class="line">         rf.electionTimer.Reset(RandomElectionTimeOut())</span><br><span class="line">      &#125;</span><br><span class="line">      rf.currentTerm = args.Term</span><br><span class="line">      rf.votedFor = <span class="number">-1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Raft 在投票阶段就确保选举出的 leader 一定包含了整个集群中目前已 committed 的所有日志。</span></span><br><span class="line">   <span class="comment">// 判断日志新旧的方式：获取请求的 entry 后，比对自己日志中的最后一个 entry。</span></span><br><span class="line">   <span class="comment">//首先比对 term，如果自己的 term 更大，则拒绝请求。</span></span><br><span class="line">   <span class="comment">//如果 term 一样，则比对 index，如果自己的 index 更大（说明自己的日志更长），则拒绝请求</span></span><br><span class="line">   <span class="keyword">if</span> args.LastLogTerm &lt; rf.getLastLog().Term || (args.LastLogTerm == rf.getLastLog().Term &amp;&amp; args.LastLogIndex &lt; rf.getLastLog().Index) &#123;</span><br><span class="line">      reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">      reply.Term = rf.currentTerm</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 注意：这是args.Term == rf.currentTerm前提下，且没有投过票</span></span><br><span class="line">   rf.votedFor = args.CandidateId</span><br><span class="line">   <span class="comment">// 为什么要还原？ -》投完票开启下一轮</span></span><br><span class="line">   rf.electionTimer.Reset(RandomElectionTimeOut())</span><br><span class="line">   reply.Term = rf.currentTerm</span><br><span class="line">   reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><h4 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h4><p>leader的term比自己还小，我们拒绝该增加entries的请求。否则我们<strong>需要刷新我们的election计时器</strong>。</p>
<p>加速：</p>
<p>在确保自己的第一条日志比leader的prevlogindex靠前时，我们就开始寻找我们的log缺失和不匹配的情况。</p>
<ol>
<li><p>自己的最后一条都没到prevlogindex？ 不够长，XTerm给-1，XLen为我们需要的log长度</p>
</li>
<li><p>自己的prevlogindex处的term和leader的不一致？ 不匹配，知道自己在prevlogindex处的term，再找到该term对应的第一槽位</p>
</li>
<li><p>没有丢失或冲突，找到leader中第一处和peer中index和term相符的地方，直接覆盖后面的entry</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">   rf.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">   <span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> DPrintf(<span class="string">&quot;[Node %v]&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; &quot;</span>+</span><br><span class="line">      <span class="string">&quot;before processing AppendEntriesArgs %v and reply AppendEntriesReply %v&quot;</span>,</span><br><span class="line">      rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), args, reply)</span><br><span class="line">   <span class="comment">// 返回假 如果领导人的任期小于接收者的当前任期 这里的接收者是指跟随者或者候选人</span></span><br><span class="line">   <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">      reply.Term = rf.currentTerm</span><br><span class="line">      reply.Success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 更新自己的任期</span></span><br><span class="line">   <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">      rf.currentTerm = args.Term</span><br><span class="line">      rf.votedFor = <span class="number">-1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 更新自己状态为Follower</span></span><br><span class="line">   rf.changeState(Follower)</span><br><span class="line">   <span class="comment">//由于自己依然是follower，需要更新</span></span><br><span class="line">   rf.reInitFollowTimer()</span><br><span class="line">   <span class="comment">//  leader的PrevLogIndex比自己的第一条log的index还小？？</span></span><br><span class="line">   <span class="keyword">if</span> args.PrevLogIndex &lt; rf.getFirstLog().Index &#123;</span><br><span class="line">      <span class="comment">// figure 8 error</span></span><br><span class="line">      reply.Term = rf.currentTerm</span><br><span class="line">      reply.Success = <span class="literal">false</span></span><br><span class="line">      DPrintf(<span class="string">&quot;[Node %v] receives unexpected AppendEntriesRequest %v from [Node %v] because prevLogIndex %v &lt; firstLogIndex %v&quot;</span>, rf.me, args, args.LeaderId, args.PrevLogIndex, rf.getFirstLog().Index)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则返回假</span></span><br><span class="line">   lastLogIndex := rf.getLastLog().Index</span><br><span class="line">   firstLogIndex := rf.getFirstLog().Index</span><br><span class="line">   <span class="comment">//prevLogIndex &gt; rf.getLastLog().Index : 当前follower存在log缺失</span></span><br><span class="line">   <span class="comment">//rf.logs[preLogIndex - firstLogIndex].Term != Term Term不匹配，存在日志冲突</span></span><br><span class="line">   <span class="keyword">if</span> args.PrevLogIndex &gt; lastLogIndex ||</span><br><span class="line">      rf.logs[args.PrevLogIndex-firstLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">      reply.Success = <span class="literal">false</span></span><br><span class="line">      reply.Term = rf.currentTerm</span><br><span class="line">      <span class="comment">// 当前Follower日志太短，以至于在冲突的位置没有Log条目，Leader应该回退到Follower最后一条Log条目的下一条</span></span><br><span class="line">      <span class="keyword">if</span> args.PrevLogIndex &gt; lastLogIndex &#123;</span><br><span class="line">         <span class="comment">//follower在对应位置没有Log，那么这里会返回 -1</span></span><br><span class="line">         reply.XTerm = <span class="number">-1</span></span><br><span class="line">         reply.XLen = args.PrevLogIndex - rf.getLastLog().Index</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//follower的日志存在冲突</span></span><br><span class="line">         <span class="comment">//将自己的任期号放在XTerm中</span></span><br><span class="line">         reply.XTerm = rf.logs[args.PrevLogIndex-firstLogIndex].Term</span><br><span class="line">         i := <span class="number">0</span></span><br><span class="line">         <span class="comment">//找到对应任期号为XTerm的第一条Log条目的槽位号</span></span><br><span class="line">         <span class="keyword">for</span> i = args.PrevLogIndex; i &gt; firstLogIndex; i-- &#123;</span><br><span class="line">            <span class="keyword">if</span> rf.logs[i-firstLogIndex].Term != reply.XTerm &#123;</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         reply.XIndex = i + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 没有发生丢失或冲突</span></span><br><span class="line">   <span class="keyword">for</span> i, entry := <span class="keyword">range</span> args.Entries &#123;</span><br><span class="line">      <span class="comment">//找到Index不合</span></span><br><span class="line">      <span class="keyword">if</span> entry.Index &gt; lastLogIndex ||</span><br><span class="line">         <span class="comment">// term不合的地方</span></span><br><span class="line">         rf.logs[entry.Index-firstLogIndex].Term != entry.Term &#123;</span><br><span class="line">         <span class="comment">//直接覆盖后面的entry</span></span><br><span class="line">         rf.logs = <span class="built_in">append</span>(rf.logs[:entry.Index-firstLogIndex], args.Entries[i:]...)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   rf.followerCommit(args.LeaderCommit)</span><br><span class="line">   reply.Term = rf.currentTerm</span><br><span class="line">   reply.Success = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h4><p>如果自己为leader且存在日志重传，我们考虑三种情况</p>
<ol>
<li><p>缺日志，我们根据xlen直接计算出nextindex</p>
</li>
<li><p>存在xterm符合，我们就将nextindex设置为自己的xindex后面的一个位置</p>
</li>
<li><p>xterm不符合，完全没找到，就返回xindex的位置，全部重来一遍吧</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntriesReply(peer <span class="type">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    <span class="comment">// 确保当前仍是Leader状态并且Term没有改变的情况下才处理reply RPC</span></span><br><span class="line">    <span class="keyword">if</span> rf.state == Leader &amp;&amp; rf.currentTerm == args.Term &#123;</span><br><span class="line">        <span class="comment">// 不是leader了</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">            rf.changeState(Follower)</span><br><span class="line">            rf.reInitFollowTimer()</span><br><span class="line">            rf.currentTerm = reply.Term</span><br><span class="line">            rf.votedFor = <span class="number">-1</span></span><br><span class="line">            rf.persist()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reply.Success &#123;</span><br><span class="line">            rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">            rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line">            rf.leaderCommit()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 3: 缺少日志</span></span><br><span class="line">            <span class="keyword">if</span> reply.XTerm == <span class="number">-1</span> &#123;</span><br><span class="line">                rf.nextIndex[peer] -= reply.XLen</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                firstLogIndex := rf.getFirstLog().Index</span><br><span class="line">                find := <span class="literal">false</span></span><br><span class="line">                <span class="keyword">for</span> i := args.PrevLogIndex; i &gt;= firstLogIndex; i-- &#123;</span><br><span class="line">                    <span class="comment">// case 2: Leader发现自己有任期的日志，它会将自己本地记录的nextIndex设置到本地在XTerm位置的Log条目后面</span></span><br><span class="line">                    <span class="comment">//figure 8 failure</span></span><br><span class="line">                    <span class="keyword">if</span> rf.logs[i-firstLogIndex].Term == reply.XTerm &#123;</span><br><span class="line">                        find = <span class="literal">true</span></span><br><span class="line">                        rf.nextIndex[peer] = reply.XIndex + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// case1 : Leader完全没有XTerm的任何Log，那么它应该回退到XIndex对应的位置</span></span><br><span class="line">                <span class="keyword">if</span> !find &#123;</span><br><span class="line">                    rf.nextIndex[peer] = reply.XIndex</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DPrintf(<span class="string">&quot;[Node %v]&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; &quot;</span>+</span><br><span class="line">            <span class="string">&quot;after handling AppendEntriesReply %v from [Node %v] for AppendEntriesArgs %v&quot;</span>,</span><br><span class="line">            rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), reply, peer, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 follower 的复制，有 snapshot 和 entries 两种方式，需要根据该 peer 的 nextIndex 来判断，也就是当前位置prevlogindex必须要符合。我们这里当然是entries方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法是发送再上一块的 entry， 如果 follower 依然拒绝，则 leader 再尝试发送更前面的一块，直到找到双方的共识点。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> doReplicate(peer <span class="type">int</span>) &#123;</span><br><span class="line">    rf.mu.RLock()</span><br><span class="line">    <span class="keyword">if</span> rf.state != Leader &#123;</span><br><span class="line">        rf.mu.RUnlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：对于一个新当选的leader，rf.nextIndex[peer]初始化为rf.getLastLog().Index + 1</span></span><br><span class="line">    <span class="comment">// 此时prevLogIndex就是leader最后一条log的index</span></span><br><span class="line">    prevLogIndex := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 只用entries就够了</span></span><br><span class="line">    <span class="keyword">if</span> prevLogIndex &gt;= rf.getFirstLog().Index &#123;</span><br><span class="line">        args := rf.genAppendEntriesArgs(prevLogIndex)</span><br><span class="line">        rf.mu.RUnlock()</span><br><span class="line">        reply := <span class="built_in">new</span>(AppendEntriesReply)</span><br><span class="line">        <span class="keyword">if</span> rf.sendAppendEntries(peer, args, reply) &#123;</span><br><span class="line">            rf.mu.Lock()</span><br><span class="line">            rf.handleAppendEntriesReply(peer, args, reply)</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>commit 日志：图 2 中规定，raft leader 只能提交当前 term 的日志，不能提交旧 term 的日志。因此 leader 根据 matchIndex[] 来 commit 日志时需要判断该日志的 term 是否等于 leader 当前的 term，即是否为当前 leader 任期新产生的日志，若是才可以提交。此外，follower 对 leader 的 leaderCommit 就不需要判断了，无条件服从即可。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>Snapshot是上层 service 主动调用 api 通知 raft peer 创建快照并存储到 persister 持久化层的；</p>
<h4 id="服务端触发的日志压缩"><a href="#服务端触发的日志压缩" class="headerlink" title="服务端触发的日志压缩"></a>服务端触发的日志压缩</h4><p>实现很简单，删除掉对应已经被压缩的 raft log 即可，留一个空的log</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">   <span class="comment">// Your code here (2D).</span></span><br><span class="line">   rf.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">   snapshotIndex := rf.getFirstLog().Index</span><br><span class="line">   <span class="keyword">if</span> snapshotIndex &gt;= index &#123;</span><br><span class="line">      DPrintf(<span class="string">&quot;[Node %v] rejects snapshotting with snapshotIndex %v as current snapshotIndex is %v in term %v&quot;</span>, rf.me, index, snapshotIndex, rf.currentTerm)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   newLogLen := <span class="built_in">len</span>(rf.logs[index-rf.getFirstLog().Index:])</span><br><span class="line">   tmp := <span class="built_in">make</span>([]Entry, newLogLen)</span><br><span class="line">   <span class="built_in">copy</span>(tmp, rf.logs[index-rf.getFirstLog().Index:])</span><br><span class="line">   rf.logs = tmp</span><br><span class="line">   rf.logs[<span class="number">0</span>].Command = <span class="literal">nil</span></span><br><span class="line">   rf.persister.SaveStateAndSnapshot(rf.encodeState(), snapshot)</span><br><span class="line">   DPrintf(<span class="string">&quot;[Node %v]&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; after replacing log with snapshotIndex %v as old snapshotIndex %v is smaller&quot;</span>, rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), index, snapshotIndex)</span><br></pre></td></tr></table></figure>


<p>而InstallSnapshot这条链路是，leader 通知 follower，即 follower 被动接受 leader 的快照，并且<strong>只是在 raft 层</strong>，而<strong>快照是需要上层 service 同时持有</strong>，所以一条完整链路应该是InstallSnapshot -&gt; applyCh -&gt; CondInstallSnapshot，引入这种处理逻辑，是为了保证上层 service 和 raft 层应用快照时是原子性地同时应用。即CondInstallSnapshot是在上层 service 拿到快照后，询问 raft 层是否一起安装快照</p>
<pre><code>    &#125; else &#123; // need snapshot
        args := rf.genInstallSnapshotArgs()
        rf.mu.RUnlock()
        reply := new(InstallSnapshotReply)
        if rf.sendInstallSnapshot(peer, args, reply) &#123;
            rf.mu.Lock()
            rf.handleInstallSnapshotReply(peer, args, reply)
            rf.mu.Unlock()
        &#125;
    &#125;
</code></pre>
<p>可以看见我们的复制也依赖这个installsnapshot，下面全是对于这条链路的考虑</p>
<p>对于 leader 发过来的 InstallSnapshot，只需要判断 term 是否正确，如果无误则 follower 只能无条件接受。并且发送快照信息进入applych</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">   rf.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">   <span class="keyword">defer</span> DPrintf(<span class="string">&quot;[Node %v]&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; before processing InstallSnapshotRequest %v and reply InstallSnapshotResponse %v&quot;</span>, rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), args, reply)</span><br><span class="line"></span><br><span class="line">   reply.Term = rf.currentTerm</span><br><span class="line">   <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">      rf.currentTerm = args.Term</span><br><span class="line">      rf.votedFor = <span class="number">-1</span></span><br><span class="line">      rf.persist()</span><br><span class="line">   &#125;</span><br><span class="line">   rf.changeState(Follower)</span><br><span class="line">   rf.electionTimer.Reset(RandomElectionTimeOut())</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> rf.commitIndex &gt;= args.LastIncludedIndex &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">         SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">         Snapshot:      args.Data,</span><br><span class="line">         SnapshotTerm:  args.LastIncludedTerm,</span><br><span class="line">         SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于服务上层触发的 CondInstallSnapshot，与上面类似，如果 snapshot 没有更新的话就没有必要去换，否则就接受对应的 snapshot 并处理对应状态的变更。注意，这里不需要判断 lastIncludeIndex 和 lastIncludeTerm 是否匹配，因为 follower 对于 leader 发来的更新的 snapshot 是<strong>无条件服从的。这时才是真正的snapshot</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="comment">// Your code here (2D).</span></span><br><span class="line">   rf.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">   <span class="comment">// 过期snapshot</span></span><br><span class="line">   <span class="keyword">if</span> lastIncludedIndex &lt;= rf.commitIndex &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> lastIncludedIndex &gt; rf.getLastLog().Index &#123;</span><br><span class="line">      rf.logs = <span class="built_in">make</span>([]Entry, <span class="number">1</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp := <span class="built_in">make</span>([]Entry, <span class="built_in">len</span>(rf.logs[lastIncludedIndex-rf.getFirstLog().Index:]))</span><br><span class="line">      <span class="built_in">copy</span>(tmp, rf.logs[lastIncludedIndex-rf.getFirstLog().Index:])</span><br><span class="line">      rf.logs = tmp</span><br><span class="line">      rf.logs[<span class="number">0</span>].Command = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   rf.logs[<span class="number">0</span>].Term = lastIncludedTerm</span><br><span class="line">   rf.logs[<span class="number">0</span>].Index = lastIncludedIndex</span><br><span class="line">   rf.lastApplied = lastIncludedIndex</span><br><span class="line">   rf.commitIndex = lastIncludedIndex</span><br><span class="line">   rf.persister.SaveStateAndSnapshot(rf.encodeState(), snapshot)</span><br><span class="line">   DPrintf(<span class="string">&quot;[Node %v]&#x27;s state is &#123;state %v,term %v,commitIndex %v,lastApplied %v,firstLog %v,lastLog %v&#125; after accepting the snapshot which lastIncludedTerm is %v, lastIncludedIndex is %v&quot;</span>, rf.me, rf.state, rf.currentTerm, rf.commitIndex, rf.lastApplied, rf.getFirstLog(), rf.getLastLog(), lastIncludedTerm, lastIncludedIndex)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="快速重传优化"><a href="#快速重传优化" class="headerlink" title="快速重传优化"></a>快速重传优化</h3><p>见日志复制</p>
<p>除开上面的快速重传优化，还使用了两个优化</p>
<h3 id="复制机制优化"><a href="#复制机制优化" class="headerlink" title="复制机制优化"></a>复制机制优化</h3><p>我们包装一个 BroadcastHeartbeat() 函数，其负责向所有 follower 发送一轮同步。不论是心跳超时还是上层服务传进来一个新 command，都去调一次这个函数来发起一轮同步。但是有很大的资源浪费。比如上层服务连续调用了几十次 Start() 函数，由于每一次调用 Start() 函数都会触发一轮日志同步，则最终导致发送了几十次日志同步。一方面，这些请求包含的 entries 基本都一样，甚至有 entry 连续出现在几十次 rpc 中，这样的实现多传输了一些数据，存在一定浪费；另一方面，每次发送 rpc 都不论是发送端还是接收端都需要若干次系统调用和内存拷贝，rpc 次数过多也会对 CPU 造成不必要的压力。总之，这种资源浪费的根本原因就在于：<strong>将日志同步的触发与上层服务提交新指令强绑定，从而导致发送了很多重复的 rpc</strong>。</p>
<p><strong>每个 peer 在启动时会为除自己之外的每个 peer 都分配一个 replicator 协程</strong>。对于 follower 节点，该协程<strong>利用条件变量执行 wait 来避免耗费 cpu，并等待变成 leader 时再被唤醒</strong>；对于 leader 节点，该协程负责尽最大地努力去向对应 follower 发送日志使其同步，直到该节点不再是 leader 或者该 follower 节点的 matchIndex 大于等于本地的 lastIndex。这样的实现方式能够将日志同步的触发和上层服务提交新指令解耦，能够大幅度减少传输的数据量，rpc 次数和系统调用次数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(peers); i++ &#123;</span><br><span class="line">		rf.matchIndex[i], rf.nextIndex[i] = <span class="number">0</span>, lastLog.Index+<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> i != rf.me &#123;</span><br><span class="line">			rf.replicatorCond[i] = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">			<span class="comment">// 启动复制器 goroutine 以批量复制条目</span></span><br><span class="line">			<span class="comment">// 分别管理对应 peer 的复制状态</span></span><br><span class="line">			<span class="keyword">go</span> rf.replicator(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicator(peer <span class="type">int</span>) &#123;</span><br><span class="line">	rf.replicatorCond[peer].L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.replicatorCond[peer].L.Unlock()</span><br><span class="line">	<span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">		<span class="keyword">for</span> !rf.needReplicating(peer) &#123;</span><br><span class="line">			rf.replicatorCond[peer].Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		rf.doReplicate(peer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> needReplicating(peer <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> rf.state == Leader &amp;&amp; rf.matchIndex[peer] &lt; rf.getLastLog().Index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> broadcastHeartbeat(isHeartbeat <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">      <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> isHeartbeat &#123;</span><br><span class="line">         <span class="comment">//立刻发送保证leader地位</span></span><br><span class="line">         <span class="keyword">go</span> rf.doReplicate(peer)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//只需向replicatorCond goroutine 发出信号即可批量发送entry</span></span><br><span class="line">         rf.replicatorCond[peer].Signal()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步-applier-的-exactly-once"><a href="#异步-applier-的-exactly-once" class="headerlink" title="异步 applier 的 exactly once"></a>异步 applier 的 exactly once</h3><p><a target="_blank" rel="noopener" href="https://cn.pingcap.com/blog/optimizing-raft-in-tikv">TiKV 功能介绍 - Raft 的优化 | PingCAP</a></p>
<p>当一个 log 被大部分节点 append 之后，我们就可以认为这个 log 被 committed 了，被 committed 的 log 在什么时候被 apply 都不会再影响数据的一致性。所以当一个 log 被 committed 之后，我们可以用另一个线程去异步的 apply 这个 log。</p>
<p>对于异步 apply，其触发方式无非两种，leader 提交了新的日志或者 follower 通过 leader 发来的 leaderCommit 来更新 commitIndex。可以在这两处异步启一个协程把 [lastApplied + 1, commitIndex] 的 entry push 到 applyCh 中，但其实这样子是可能重复发送 entry 的，原因是 push applyCh 的过程不能够持锁，那么这个 lastApplied 在没有 push 完之前就无法得到更新，从而可能被多次调用。虽然只要上层服务可以保证不重复 apply 相同 index 的日志到状态机就不会有问题，但不优雅。</p>
<p>考虑到异步 apply 时最耗时的步骤是 apply channel 和 apply 日志到状态机，其他的都不怎么耗费时间。因此我们完全<strong>可以只用一个 applier 协程，让其不断的把 [lastApplied + 1, commitIndex] 区间的日志 push 到 applyCh 中去</strong>。这样既可保证每一条日志只会被 exactly once 地 push 到 applyCh 中，也可以使得日志 apply 到状态机和 raft 提交新日志可以真正的并行。这是一个较为优雅的异步 apply 实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> rf.applier()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applier() &#123;</span><br><span class="line">   <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">      rf.mu.Lock()</span><br><span class="line">      <span class="keyword">for</span> rf.lastApplied &gt;= rf.commitIndex &#123;</span><br><span class="line">         rf.applyCond.Wait()</span><br><span class="line">      &#125;</span><br><span class="line">      lastApplied := rf.lastApplied</span><br><span class="line">      firstLogIndex := rf.getFirstLog().Index</span><br><span class="line">      commitIndex := rf.commitIndex</span><br><span class="line">      applyEntries := <span class="built_in">make</span>([]Entry, commitIndex-lastApplied)</span><br><span class="line">      <span class="built_in">copy</span>(applyEntries, rf.logs[lastApplied-firstLogIndex+<span class="number">1</span>:commitIndex-firstLogIndex+<span class="number">1</span>])</span><br><span class="line">      rf.mu.Unlock()</span><br><span class="line">      <span class="keyword">for</span> _, entry := <span class="keyword">range</span> applyEntries &#123;</span><br><span class="line">         applyMsg := ApplyMsg&#123;</span><br><span class="line">            CommandValid: <span class="literal">true</span>,</span><br><span class="line">            Command:      entry.Command,</span><br><span class="line">            CommandIndex: entry.Index,</span><br><span class="line">         &#125;</span><br><span class="line">         rf.applyCh &lt;- applyMsg</span><br><span class="line">      &#125;</span><br><span class="line">      rf.mu.Lock()</span><br><span class="line">      rf.lastApplied = Max(rf.lastApplied, commitIndex)</span><br><span class="line">      rf.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> followerCommit(leaderCommit <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> leaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">      rf.commitIndex = Min(leaderCommit, rf.getLastLog().Index)</span><br><span class="line">      rf.applyCond.Signal()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> leaderCommit() &#123;</span><br><span class="line">   <span class="comment">//注意：是根据matchIndex，判断出那些log已经被大多数peer记录了</span></span><br><span class="line">   n := <span class="built_in">len</span>(rf.matchIndex)</span><br><span class="line">   tmp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">   <span class="built_in">copy</span>(tmp, rf.matchIndex)</span><br><span class="line">   <span class="comment">//降序排序</span></span><br><span class="line">   sort.Sort(sort.Reverse(sort.IntSlice(tmp)))</span><br><span class="line">   <span class="comment">//找到新的commitIndex</span></span><br><span class="line">   newCommitIndex := tmp[n/<span class="number">2</span>]</span><br><span class="line">   <span class="keyword">if</span> newCommitIndex &gt; rf.commitIndex &#123;</span><br><span class="line">      <span class="comment">// leader只能提交当前任期下的日志</span></span><br><span class="line">      <span class="keyword">if</span> newCommitIndex &lt;= rf.getLastLog().Index &amp;&amp; rf.currentTerm == rf.logs[newCommitIndex-rf.getFirstLog().Index].Term &#123;</span><br><span class="line">         DPrintf(<span class="string">&quot;[Node %d] advance commitIndex from %d to %d with matchIndex %v in term %d&quot;</span>,</span><br><span class="line">            rf.me, rf.commitIndex, newCommitIndex, rf.matchIndex, rf.currentTerm)</span><br><span class="line">         rf.commitIndex = newCommitIndex</span><br><span class="line">         rf.applyCond.Signal()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         DPrintf(<span class="string">&quot;[Node %d] can not advance commitIndex from %d because the term of newCommitIndex %d is not equal to currentTerm %d&quot;</span>,</span><br><span class="line">            rf.me, rf.commitIndex, newCommitIndex, rf.currentTerm)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="figure8"><a href="#figure8" class="headerlink" title="figure8"></a><strong>figure8</strong></h2><p><img src="https://cdn.staticaly.com/gh/KatoTohka/pic1@main/202302211946986.png" alt="img">..</p>
<p>Figure 8 用来说明为什么 Leader 不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志。</p>
<p>先按错误的情况，也就是 Leader 可以提交之前任期的日志。那么上述的流程：</p>
<ul>
<li>(a) S1 是任期 2 的 Leader(<em>仔细看，有个黑框</em>)，日志已经复制到了 S2。</li>
<li>(b) S1 宕机，S5 获得 S3、S4 和 S5 的选票成为 Leader，然后写了一条日志 index&#x3D;2 &amp; term&#x3D;3。</li>
<li>(c) S5 刚写完就宕机了，S1 重新当选 Leader，currentTerm &#x3D; 4，<strong>此刻还没有新的请求进来</strong>，S1 将 index&#x3D;2 &amp; term &#x3D; 2 的日志复制到了 S3，多数派达成，S1 提交了这个日志(注意，<strong>term&#x3D;2 不是当前任期的日志，我们在讨论错误的情况</strong>)。然后请求进来，刚写了本地 index&#x3D;3 &amp; term&#x3D;4 的日志，S1 就故障了。</li>
<li>(d) 这时候 S5 可以通过来自 S2、S3、S4 和自己的投票，重新成为 Leader(currentTerm&gt;&#x3D;5)，并将 index&#x3D;2 &amp;&amp; term&#x3D;3 的日志复制到其他所有节点并提交，此时 <strong>index&#x3D;2 的日志提交了两次！</strong>一次 term&#x3D;2，一次term&#x3D;3，这是绝对不允许发生的，<strong>已经提交的日志不能够被覆盖</strong>！</li>
<li>(e) 这里的情况是，S1 在宕机之前将自己 term&#x3D;4 的日志复制到了大多数机器上，这样 S5 就不可能选举成功。这是 S1 不发生故障，正确复制的情况。</li>
</ul>
<p>这里主要通过 (c) 和 (d) 来说明问题所在。其实这张图用 Raft 大论文的图会比较好理解。(d) 和 (e) 分别对应 term&#x3D;4 有没有复制到多数派的情况。</p>
<img src="https://cdn.staticaly.com/gh/KatoTohka/pic1@main/202302211946210.png" alt="img" style="zoom:50%;" />

<p>所以，<strong>我们要增加提交的约束，不让 (d) 这种情况发生。</strong>这个约束就是，Leader 只能提交自己任期的日志。</p>
<p>我们再来看看，加了约束后会变成什么样？前面 (a) 和 (b) 没有任何改变，我们从 (c) 开始。</p>
<p>(c) 还是将 index&#x3D;2 &amp; term&#x3D;2 复制到大多数，<strong>由于 currentTerm &#x3D; 4，所以不能提交这条日志。如果 S1 将 term &#x3D; 4 的日志复制到多数派，那么 Leader 就可以提交日志，index&#x3D;2 &amp; term&#x3D;2 也会间接一起提交，其实这就是 (e) 的情况，1-2-4 都被提交</strong>。</p>
<p>(d) 的情况我觉得是理解问题的关键。如果 S1 只将 term&#x3D;4 写入自己的日志，然后宕机了；S5 选举成功成为 Leader，然后将 index&#x3D;2 &amp; term&#x3D;3 的日志复制到所有节点，现在 index&#x3D;2 是没有提交过的，S5 能提交 index&#x3D;2 &amp; term&#x3D;3 的日志吗？</p>
<p>答案是不能。<strong>因为 S5 在 S1(term&#x3D;4) 选举出来后 currentTerm 至少是 5</strong>，也可能是 6、7、8……我们假设就是 5，<strong>但这条日志 term &#x3D; 3，Leader 不能提交之前任期的日志，所以这条日志是不能提交的</strong>。<strong>只有等到新的请求进来，超过半数节点复制了 1-3-5 后，term&#x3D;3 的日志才能跟着 term&#x3D;5 的一起提交</strong>。</p>
<h2 id="幽灵复现"><a href="#幽灵复现" class="headerlink" title="幽灵复现"></a><strong>幽灵复现</strong></h2><p>虽然加了这个约束不会重复提交了，但如果一直没新的请求进来，<strong>index&#x3D;2 &amp; term&#x3D;3 岂不是就一直不能提交？</strong>那这里不就阻塞了吗？如果这里是 kv 数据库，问题就很明显了。假设 (c) 或 (d) 中 index&#x3D;2 那条日志里的 Command 是 Set(“k”, “1”)，S5 当选 Leader 后，客户端来查询 Get(“k”)，Leader 查到日志有记录但又不能回复 1 给客户端(因为按照约束这条日志未提交)，线性一致性要求不能返回陈旧的数据，Leader 迫切地需要知道这条日志到底能不能提交。</p>
<p>所以 raft 论文提到了引入 no-op 日志来解决这个问题。这个在 etcd 中有实现。</p>
<h2 id="引入-no-op-日志"><a href="#引入-no-op-日志" class="headerlink" title="引入 no-op 日志"></a><strong>引入 no-op 日志</strong></h2><p>no-op 日志即只有 index 和 term 信息，command 信息为空。也是要写到磁盘存储的。</p>
<p>具体流程是在 Leader 刚选举成功的时候，立即追加一条 no-op 日志，并立即复制到其它节点，no-op 日志一经提交，Leader 前面那些未提交的日志全部间接提交，问题就解决了。像上面的 kv 数据库，有了 no-op 日志之后，Leader 就能快速响应客户端查询了。</p>
<p>本质上，no-op 日志使 Leader 隐式地快速提交之前任期未提交的日志，确认当前 commitIndex，这样系统才会快速对外正常工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>TXY的github</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jzx05Q781ytMXrZ2wrm2Vg">Raft 的 Figure 8 讲了什么问题？为什么需要 no-op 日志？ (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/425615927">MIT6.824_2021_lab2D_log_compaction - 知乎 (zhihu.com)</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/raft/">raft</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/02/20/hello-world/"><span>Hello World</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/02/20/hello-world/" rel="bookmark">
        <time class="entry-date published" datetime="2023-02-20T08:50:37.130Z">
          2023-02-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 John Doe
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>